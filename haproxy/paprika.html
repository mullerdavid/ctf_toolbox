<!DOCTYPE html> <!-- https://github.com/HUCyberTeam/paprika by @12Boti -->
<script type="module">
  const elastic = "/elastic";
  const server_ip = "10.60.17.1"; //TODO: modify it

  const flows_query = `
    FROM packets-*
    | WHERE layers.tcp.tcp_tcp_payload_raw IS NOT NULL
    | WHERE layers.tcp.tcp_tcp_payload_raw RLIKE "<POS_REGEX>" OR layers.tcp.tcp_tcp_payload_raw RLIKE "<NEG_REGEX>"
    | EVAL matches_pos=TO_INTEGER(layers.tcp.tcp_tcp_payload_raw RLIKE "<POS_REGEX>")
    | EVAL matches_neg=TO_INTEGER(layers.tcp.tcp_tcp_payload_raw RLIKE "<NEG_REGEX>")
    | LIMIT 10000
    | STATS
        size=SUM(layers.tcp.tcp_tcp_len),
        ports=VALUES(layers.tcp.tcp_tcp_port),
        time=MIN(timestamp),
        matches_pos=MAX(matches_pos),
        matches_neg=MAX(matches_neg)
      BY
        file, stream=layers.tcp.tcp_tcp_stream
    | WHERE size > 0
    | WHERE matches_pos > 0 AND matches_neg == 0
    | SORT time DESC
    | LIMIT 100
    | KEEP size, ports, time, file, stream
  `;

  const flow_data_query = `
    FROM packets-*
    | WHERE layers.tcp.tcp_tcp_payload_raw IS NOT NULL
    | EVAL seq_str=TO_STRING(layers.tcp.tcp_tcp_seq)
    | EVAL seq=CONCAT(REPEAT("0", 10-LENGTH(seq_str)), seq_str)
    | STATS
        data=VALUES(
          MV_ZIP(MV_ZIP(MV_ZIP(
            TO_STRING(timestamp),
            seq),
            TO_STRING(layers.ip.ip_ip_src)),
            layers.tcp.tcp_tcp_payload_raw))
      BY
        file, stream=layers.tcp.tcp_tcp_stream
    | WHERE file == ? AND stream == ?
    | EVAL data=MV_SORT(data)
    | LIMIT 1
    | KEEP data
  `;

  await new Promise((r) =>
    document.addEventListener("DOMContentLoaded", r, { once: true })
  );

  let currently_open_flow_id = null;

  const flows_panel = document.getElementsByTagName("flows-panel")[0];
  const data_panel = document.getElementsByTagName("data-panel")[0];
  const notice_box = document.getElementsByTagName("notice-box")[0];

  const search_port_num = document.getElementById("search_port_num");
  const search_regex_pos = document.getElementById("search_regex_pos");
  const search_regex_neg = document.getElementById("search_regex_neg");

  /** @type {Record<string, HTMLTemplateElement>} */
  const templates = [...document.getElementsByTagName("template")].reduce(
    (acc, el) => {
      acc[el.id] = el;
      return acc;
    },
    {}
  );
  /**
   * @param {string} id
   * @returns {HTMLElement}
   */
  function from_template(id) {
    return templates[id].content.cloneNode(true).firstElementChild;
  }

  async function sleep(ms, { signal }) {
    return new Promise((resolve, reject) => {
      const id = setTimeout(resolve, ms);
      signal.addEventListener("abort", () => {
        clearTimeout(id);
        reject(new DOMException("Aborted", "AbortError"));
      });
    });
  }

  const escape_regex = (r) => r.replace("\\", "\\\\").replace('"', '\\"');

  async function get_flows(port, pos_regex, neg_regex, { signal }) {
    const r = await fetch(elastic + "/_query", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        query: flows_query
          .replace(/<POS_REGEX>/g, escape_regex(pos_regex))
          .replace(/<NEG_REGEX>/g, escape_regex(neg_regex)),
        filter: port
          ? {
              term: {
                "layers.tcp.tcp_tcp_port": port,
              },
            }
          : undefined,
      }),
      signal,
    });
    if (!r.ok) throw new Error("Failed to fetch flows");
    const j = await r.json();
    return j.values.map(([size, ports, time, file, stream]) => ({
      id: file + "-" + stream,
      size,
      ports: ports,
      time: new Date(time),
    }));
  }

  let update_abort_controller = new AbortController();
  async function update_flows() {
    update_abort_controller.abort();
    update_abort_controller = new AbortController();
    const signal = update_abort_controller.signal;

    try {
      update_url();
      notice_box.textContent = "loading flows";

      const flows = await get_flows(
        search_port_num.value ? +search_port_num.value : null,
        search_regex_pos.value ? ".*(" + search_regex_pos.value + ").*" : ".*",
        search_regex_neg.value ? ".*(" + search_regex_neg.value + ").*" : "",
        { signal }
      );
      flows_panel.replaceChildren(
        ...flows.map((flow) => {
          const el = from_template("flow_card");
          el.querySelector("time").textContent =
            flow.time.toLocaleTimeString("hu-HU");
          el.querySelectorAll("port-num")[0].textContent = flow.ports[0];
          el.querySelectorAll("port-num")[1].textContent = flow.ports[1];
          el.querySelector("flow-size").textContent = flow.size;
          el.dataset.id = flow.id;
          return el;
        })
      );
      document
        .querySelector(`flow-card[data-id="${currently_open_flow_id}"]`)
        ?.classList.add("active");

      notice_box.textContent = "";
    } catch (e) {
      notice_box.textContent = e.toString();
      throw e;
    }
  }

  async function get_flow_data(flow_id, { signal }) {
    const [_, file, stream] = /(.+)-(\d+)/.exec(flow_id);
    const r = await fetch(elastic + "/_query", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        query: flow_data_query,
        params: [file, +stream],
      }),
      signal,
    });
    if (!r.ok) throw new Error("Failed to fetch flows");
    const j = await r.json();

    // If there is only one message, elastic doesn't put it into an array
    if (!Array.isArray(j.values[0][0])) j.values[0][0] = [j.values[0][0]];

    const data = j.values[0][0].map((/** @type {string} */ msg) => {
      const time = msg.slice(0, msg.indexOf(","));
      msg = msg.slice(msg.indexOf(",") + 1);
      const seq = msg.slice(0, msg.indexOf(","));
      msg = msg.slice(msg.indexOf(",") + 1);
      const sender = msg.slice(0, msg.indexOf(","));
      const data = msg.slice(msg.indexOf(",") + 1);
      return {
        time: new Date(time),
        sender: sender === server_ip ? "server" : "client",
        data,
      };
    });
    for (let i = 0; i < data.length - 1; i++) {
      if (data[i].sender === data[i + 1].sender) {
        data[i].data += data[i + 1].data;
        data.splice(i + 1, 1);
        i--;
      }
    }
    return { data };
  }

  /**
   * @param {string} data
   * @returns {HTMLElement}
   */
  function binary_to_html(data) {
    const el = document.createElement("binary-data");
    el.appendChild(document.createTextNode(""));
    for (const char of data) {
      const code = char.charCodeAt(0);
      if (code >= 32 && code <= 126 && code != 92) {
        el.lastChild.appendData(char);
      } else if (code === 10) {
        el.appendChild(
          document.createElement("binary-byte")
        ).textContent = `\\n`;
        el.appendChild(document.createTextNode(""));
        el.lastChild.appendData(char);
      } else if (code === 9) {
        el.appendChild(
          document.createElement("binary-byte")
        ).textContent = `\\t`;
        el.appendChild(document.createTextNode(""));
      } else if (code === 13) {
        el.appendChild(
          document.createElement("binary-byte")
        ).textContent = `\\r`;
        el.appendChild(document.createTextNode(""));
      } else if (code === 92) {
        el.appendChild(
          document.createElement("binary-byte")
        ).textContent = `\\\\`;
        el.appendChild(document.createTextNode(""));
      } else {
        el.appendChild(
          document.createElement("binary-byte")
        ).textContent = `\\x${code.toString(16).padStart(2, "0")}`;
        el.appendChild(document.createTextNode(""));
      }
    }
    return el;
  }

  let open_abort_controller = new AbortController();
  async function open_flow(flow_id) {
    open_abort_controller.abort();
    open_abort_controller = new AbortController();
    const signal = open_abort_controller.signal;

    try {
      currently_open_flow_id = flow_id;
      update_url();
      document.querySelector("flow-card.active")?.classList.remove("active");
      document
        .querySelector(`flow-card[data-id="${flow_id}"]`)
        ?.classList.add("active");
      notice_box.textContent = "loading flow data";

      const { data } = await get_flow_data(flow_id, { signal });
      data_panel.replaceChildren(
        ...data.map((msg) => {
          const el = from_template("stream_msg");
          el.dataset.sender = msg.sender;
          el.replaceChildren(binary_to_html(msg.data));
          return el;
        })
      );

      notice_box.textContent = "";
      data_panel.scrollTo({ top: 0 });
    } catch (e) {
      notice_box.textContent = e.toString();
      throw e;
    }
  }

  let updating_hash = false;
  function update_url() {
    updating_hash = true;
    location.hash = encodeURIComponent(
      JSON.stringify({
        pos: search_regex_pos.value,
        neg: search_regex_neg.value,
        port: search_port_num.value,
        open: currently_open_flow_id,
      })
    );
    updating_hash = false;
  }

  /**
   * @param {string} selector
   * @param {string} event
   * @param {(el: HTMLElement) => void} callback
   */
  function on(selector, event, callback) {
    document.addEventListener(
      event,
      (e) => {
        const el = e.target.closest(selector);
        if (el) {
          callback(el, e);
        }
      },
      { passive: true }
    );
  }

  on("flow-card", "click", (el) => open_flow(el.dataset.id));
  on("textarea", "input", (el) => {
    el.style.height = "auto";
    el.style.height = el.scrollHeight + "px";
  });
  on("search-panel button", "click", () => update_flows());

  const abort_controller = new AbortController();
  const signal = abort_controller.signal;

  async function update_from_hash() {
    if (updating_hash) return;
    const d = location.hash
      ? JSON.parse(decodeURIComponent(location.hash.slice(1)))
      : {};
    search_regex_pos.value = d.pos || "";
    search_regex_neg.value = d.neg || "";
    search_port_num.value = d.port || "";
    currently_open_flow_id = d.open || null;
    await update_flows({ signal });
    if (d.open) {
      await open_flow(d.open);
    }
  }
  update_from_hash();
  window.addEventListener("popstate", update_from_hash);
</script>
<style>
  *:where(
      :not(html, iframe, canvas, img, svg, video, audio):not(svg *, symbol *)
    ) {
    all: unset;
    display: revert;
  }

  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  :root {
    --rosewater: #dc8a78;
    --flamingo: #dd7878;
    --pink: #ea76cb;
    --mauve: #8839ef;
    --red: #d20f39;
    --maroon: #e64553;
    --peach: #fe640b;
    --yellow: #df8e1d;
    --green: #40a02b;
    --teal: #179299;
    --sky: #04a5e5;
    --sapphire: #209fb5;
    --blue: #1e66f5;
    --lavender: #7287fd;
    --text: #4c4f69;
    --subtext1: #5c5f77;
    --subtext0: #6c6f85;
    --overlay2: #7c7f93;
    --overlay1: #8c8fa1;
    --overlay0: #9ca0b0;
    --surface2: #acb0be;
    --surface1: #bcc0cc;
    --surface0: #ccd0da;
    --base: #eff1f5;
    --mantle: #e6e9ef;
    --crust: #dce0e8;

    --left-width: 20rem;
    font-size: 16px;
    font-family: monospace;
    scrollbar-color: var(--sky) var(--mantle);
  }

  ::selection {
    background-color: var(--blue);
    color: var(--base);
  }

  body {
    width: 100%;
    height: 100vh;
    background-color: var(--base);
    color: var(--text);

    display: grid;
    grid-template-columns: var(--left-width) 1fr;
  }

  left-panel,
  flows-panel,
  data-panel {
    min-height: 0;
  }

  flows-panel,
  data-panel {
    overflow-y: auto;
  }

  left-panel {
    display: flex;
    flex-direction: column;
  }

  search-panel {
    background-color: var(--surface0);
  }

  flows-panel {
    display: grid;
    grid-template-columns: 1fr 6ch 1ch 6ch 1fr;
  }

  flow-card {
    display: grid;
    grid-column: span 5;
    grid-template-columns: subgrid;
    gap: 2px;
    margin: 0.1rem;
    background-color: var(--overlay2);
    --border-color: var(--surface0);
    border: 4px solid var(--border-color);

    &.active {
      --border-color: var(--blue);
    }

    & time,
    & flow-ports,
    & flow-size {
      background-color: var(--surface0);
      padding: 0.2rem 0.1rem;
    }

    & flow-ports {
      display: grid;
      grid-column: span 3;
      grid-template-columns: subgrid;
      text-align: center;
    }

    & time,
    & port-num,
    & flow-size {
      text-align: right;
    }

    & port-num {
      color: var(--blue);
    }

    & flow-size {
      color: var(--maroon);
    }
  }

  data-panel {
    display: flex;
    flex-direction: column;
  }

  stream-msg {
    border-top: 2px solid var(--overlay2);
    border-left: 3px solid var(--direction-color);
    padding-left: 0.5rem;

    &[data-sender="client"] {
      --direction-color: var(--red);
    }

    &[data-sender="server"] {
      --direction-color: var(--green);
    }
  }

  binary-data {
    white-space: pre;
  }

  binary-byte {
    color: var(--yellow);
  }

  input,
  textarea {
    background-color: var(--surface2);
    width: 100%;
    word-wrap: break-word;

    &[type="number"]::-webkit-outer-spin-button,
    &[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    &[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }
  }

  search-panel button {
    background-color: var(--green);
    color: var(--base);
    width: 100%;
    height: 2rem;
  }

  notice-box {
    position: absolute;
    bottom: 0;
    right: 0;
    background-color: var(--flamingo);
  }
</style>
<title>Paprika</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<left-panel>
  <search-panel>
    <label>
      port:
      <input id="search_port_num" type="number" min="1" max="65536" />
    </label>
    <label>
      includes regex:
      <textarea id="search_regex_pos"></textarea>
    </label>
    <label>
      does not include regex:
      <textarea id="search_regex_neg"></textarea>
    </label>
    <button>search</button>
  </search-panel>
  <flows-panel></flows-panel>
</left-panel>
<data-panel></data-panel>
<notice-box></notice-box>

<template id="flow_card">
  <flow-card>
    <time></time>
    <flow-ports> <port-num></port-num>-<port-num></port-num> </flow-ports>
    <flow-size></flow-size>
  </flow-card>
</template>

<template id="stream_msg">
  <stream-msg></stream-msg>
</template>
